/*****************************************************************************
  FileName:        main.c
  Processor:       PIC32MM0256GPM048
  Compiler:        XC32 ver 2.10
  IDE :            MPLABX-IDE 5.10
  Created by:      http://strefapic.blogspot.com
 ******************************************************************************/
/*---------------------------------------------------------------*/
/* FAT file system module test program                           */
/*---------------------------------------------------------------*/
// ** Sample application for PIC32MM **
//
//    
//	  Required connections for LCD:
//     - E   -  RB11 
//     - RS  -  RB10 
//     - D7  -  RD0 
//     - D6  -  RC5 
//     - D5  -  RC4 
//     - D4  -  RC3
//   
//    Reqired connections for SD card:
//     - SCK   - RA0 
//     - MISO  - RA1 
//     - MOSI  - RA3 
//     - CS    - RB3 
//
//******************************************************************************

#include "mcc_generated_files/system.h"
#include <string.h>
#include "ff.h"
#include "diskio.h"
#include "integer.h"
#include "mmc_pic32mm.h"
#include <stdlib.h>
#include "delay.h"
#include "dogm162.h"
#include "mcc_generated_files/tmr1.h"

DWORD AccSize;			/* Work register for fs command */
WORD AccFiles, AccDirs;
FILINFO Finfo;
FATFS FatFs;		/* File system object */
FIL File[2];	    /* File objects */
TCHAR Buff[128];		/* Working buffer */


volatile UINT Timer;	/* 1kHz increment timer */
volatile WORD rtcYear = 2018;
volatile BYTE rtcMon = 11, rtcMday = 11, rtcHour, rtcMin, rtcSec;

/*---------------------------------------------------------*/
/* 1000Hz timer interrupt generated by Timer1              */
/*---------------------------------------------------------*/

void __attribute__ ((vector(_TIMER_1_VECTOR), interrupt(IPL1SOFT))) TMR1_ISR()
{
	static const BYTE samurai[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	static UINT div1k;
	BYTE n;


	IFS0CLR= 1 << _IFS0_T1IF_POSITION;			/* Clear irq flag */
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */

	/* Real Time Clock */
	if (++div1k >= 1000) {
		div1k = 0;
		if (++rtcSec >= 60) {
			rtcSec = 0;
			if (++rtcMin >= 60) {
				rtcMin = 0;
				if (++rtcHour >= 24) {
					rtcHour = 0;
					n = samurai[rtcMon - 1];
					if ((n == 28) && !(rtcYear & 3)) n++;
					if (++rtcMday > n) {
						rtcMday = 1;
						if (++rtcMon > 12) {
							rtcMon = 1;
							rtcYear++;
						}
					}
				}
			}
		}
	}
}


/*---------------------------------------------------------*/
/* User Provided RTC Function for FatFs module             */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support an RTC.                     */
/* This function is not required in read-only cfg.         */

DWORD get_fattime (void)
{
	DWORD tmr;


	//INTERRUPT_GlobalDisable();//_DI();
	/* Pack date and time into a DWORD variable */
	tmr =	  (((DWORD)rtcYear - 1980) << 25)
			| ((DWORD)rtcMon << 21)
			| ((DWORD)rtcMday << 16)
			| (WORD)(rtcHour << 11)
			| (WORD)(rtcMin << 5)
			| (WORD)(rtcSec >> 1);
	//INTERRUPT_GlobalEnable();//_EI();

	return tmr;
}
                             

static
FRESULT scan_files (
	char* path		/* Pointer to the path name working buffer */
)
{
	DIR dirs;
	FRESULT res;
	int i;

	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
			if (Finfo.fattrib & AM_DIR) {
				i = strlen(path);
				AccDirs++;
				path[i] = '/'; strcpy(&path[i+1], Finfo.fname);
				res = scan_files(path);
				path[i] = 0;
				if (res != FR_OK) break;
			} else {
#if 0
				//xprintf("%s/%s\n", path, fn);
#endif
				AccFiles++;
				AccSize += Finfo.fsize;
			}
		}
	}

	return res;
}


/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
	//char *ptr, *ptr2;
	const BYTE ft[] = {0,12,16,32};
	UINT s1,s2,cnt;
	//DWORD ofs = 0, sect = 0;
	FRESULT res;
	FATFS *fs;				/* Pointer to file system object */
	DIR dir;				/* Directory object */

    // Enable the Global Interrupts
    //INTERRUPT_GlobalEnable();

    // Disable the Global Interrupts
    //INTERRUPT_GlobalDisable();
	
    SYSTEM_Initialize();
    TMR1_Start();       
	lcd_Initialize();
	lcd_Cls();
	lcd_String("SD Card Test");
	delayMs(1000);
    
    /*Mount device*/	
	if(f_mount(&FatFs, "", 0)!=FR_OK) {
		lcd_Locate(0,0);
		lcd_String("f_mount error!");
		while(1);
	}
    else
    {
        lcd_Cls();
        lcd_String("f.mount OK.! ");
        delayMs(1000);
    }
    
    /*Initialize drive*/
	DSTATUS driveStatus = disk_initialize(0);
    if(!driveStatus)
    {
       lcd_Cls(); 
       lcd_String("disk init OK.! ");
       delayMs(1000);
    }
    else
    {
       lcd_Cls(); 
       lcd_String("disk init error");
       lcd_Locate(2,1);
       lcd_Integer(driveStatus); //Display number error
       while(1);
    }
        
   /*Create file plik.txt*/
    res = f_open(&File[0], "plik.txt", FA_CREATE_ALWAYS);
    if(!res)
    {
       lcd_Cls(); 
       lcd_String("create file OK.!");
       f_close(&File[0]);
       delayMs(1000);
    }
    else
    {
       lcd_Cls(); 
       lcd_String("create file err");
       lcd_Locate(2,1);
       lcd_Integer(res); //Display number error
       while(1);
    }
                
    /*Write data to file plik.txt*/
    res = f_open(&File[0], "plik.txt", FA_WRITE);
    res = f_write(&File[0], "Hello I'm write", 15, &s1);
    if(!res)
    {
       lcd_Cls(); 
       lcd_String("write data OK.!");
       f_close(&File[0]);
       delayMs(1000);
    }
    else
    {
       lcd_Cls(); 
       lcd_String("write data err");
       lcd_Locate(2,1);
       lcd_Integer(res); //Display number error
       while(1);
    }
         
    /*read data from file*/
   	res = f_open(&File[0], "plik.txt", FA_READ);
    if(res)
    {
       lcd_Cls(); 
       lcd_String("open file err");
       lcd_Locate(2,1);
       lcd_Integer(res); //Display number error
       while(1);
    }
    res = f_read(&File[0],Buff, 15, &s2);
	if (res) { 
        lcd_Locate(2,1);
        lcd_Integer(res); //Display number error
        while(1);
    }
	f_close(&File[0]);
   
    /*display the contents of the buffer*/
    lcd_Cls(); 
    lcd_String(Buff);
    
    lcd_Locate(2,1);
    lcd_String("ALL OK !");
        
    while(1);
    
}


